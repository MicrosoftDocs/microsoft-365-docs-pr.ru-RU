---
title: Справочные материалы по защите от эксплойтов
keywords: меры для предотвращения, уязвимости, уязвимость, мера для предотвращения, эксплойт, эксплойты, emet
description: Сведения о том, как функция защиты от эксплойтов работает в Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: 7300ed2a4dc2623a8f936006ce7de3a5204712f0
ms.sourcegitcommit: 4fb1226d5875bf5b9b29252596855a6562cea9ae
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2021
ms.locfileid: "52844546"
---
# <a name="exploit-protection-reference"></a>Справка о защите от эксплойтов

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**Область применения:**
- [Microsoft Defender для конечной точки](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>Хотите испытать Microsoft Defender для конечной точки? [Зарегистрився для бесплатной пробной.](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

Защита от эксплойтов обеспечивает расширенные средства защиты для приложений, которые ИТ-Pro применять после компиляции и распространения программного обеспечения разработчиком.

В этой статье вы сможете понять, как работает защита от эксплойтов как на уровне политики, так и на уровне отдельных мер по смягчению последствий, чтобы успешно создавать и применять политики защиты от эксплойтов.

## <a name="how-mitigations-are-applied"></a>Как применяются меры по смягчению последствий

В приложении применяются меры по смягчению последствий защиты от эксплойтов.

Меры по смягчению последствий настраиваются с помощью записи реестра для каждой программы, для которых настроены средства защиты. Эти параметры хранятся в записи реестра **MitigationOptions** для каждой программы (HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Параметры выполнения файлов изображений **\ *ImageFileName* \ MitigationOptions**). Они вступает в силу при перезапуске программы и остаются эффективными до тех пор, пока вы не измените ее и снова перезапустите программу.

> [!IMPORTANT]
> Параметры выполнения файлов изображений позволяют указать только имя или путь файла, а не номер версии, архитектуру или любой другой дифференциатор. Будьте осторожны, чтобы нацелить смягчение последствий на приложения с уникальными именами или путями, применяя их только на устройствах, где вы протестировали эту версию и архитектуру приложения.

При настройке смягчения защиты от эксплойтов с помощью XML-файла конфигурации с помощью PowerShell, Групповой политики или MDM при обработке этого XML-файла конфигурации для вас будут настроены отдельные параметры реестра.

Если политика распространения XML-файла больше не выполняется, параметры, развернутые этим файлом конфигурации XML, автоматически не удаляются. Чтобы удалить параметры exploit Protection, экспортировать конфигурацию XML с Windows 10 устройства и развернуть новый XML-файл. Кроме того, Корпорация Майкрософт предоставляет XML-файл в Безопасность Windows базовых данных для сброса параметров защиты от эксплойтов.

Чтобы сбросить параметры защиты эксплойтов с помощью PowerShell, можно использовать следующую команду:

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Ниже приводится EP-reset.xml с базовыми Безопасность Windows:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Справка о смягчении последствий

В следующих разделах подробно рассматриваются меры защиты, предоставляемые каждым смягчением защиты от эксплойтов, соображения совместимости для смягчения и доступные параметры конфигурации.

## <a name="arbitrary-code-guard"></a>Произвольный охранник кода

### <a name="description"></a>Описание

Произвольный охранник кода помогает защититься от злоумышленника, загружающего код по своему выбору в память с помощью уязвимости в области безопасности памяти и возможности выполнения этого кода.

Защита произвольного кода защищает приложение от выполнения динамического кода (код, который не загружается, например, от самого exe или dll). Произвольный охранник кода работает, не мешая пометить память как исполняемую. Когда приложение пытается [выделить память,](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)мы проверяем флаги защиты. (Память может быть выделена с помощью флагов чтения, записи и/или выполнения.) Если выделение пытается включить [](/windows/win32/memory/memory-protection-constants) флаг защиты выполнения, выделение памяти не выполняется и возвращает код ошибки (STATUS_DYNAMIC_CODE_BLOCKED). Аналогичным образом, если приложение [](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) пытается изменить уже выделенные флаги памяти и [](/windows/win32/memory/memory-protection-constants) включает флаг защиты выполнения, изменение разрешения не выполняется и возвращает код ошибки (STATUS_DYNAMIC_CODE_BLOCKED).

Предотвращая  задавание флага выполнения, функция предотвращения выполнения данных Windows 10 затем может защитить от указания инструкции, задаемого этой памяти и запускаемого кода.

### <a name="compatibility-considerations"></a>Соображения совместимости

Произвольный охранник кода не позволяет использовать любую память в качестве исполняемой, что представляет проблему совместимости с такими подходами, как компиляторы Just-in-Time (JIT). Например, большинство современных браузеров будут компилировать JavaScript в исходный код, чтобы оптимизировать производительность. Чтобы поддержать это смягчение, их необходимо перезахотрить, чтобы переместить компиляцию JIT за пределы защищенного процесса. Другие приложения, дизайн которых динамически генерирует код из скриптов или других промежуточных языков, также несовместимы с этим смягчением.

### <a name="configuration-options"></a>Параметры конфигурации

**Разрешить отказ от потока** — можно настроить смягчение, чтобы отдельный поток отказался от этой защиты. Разработчик должен был написать приложение с пониманием этого смягчения и назвать API [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) с параметром *ThreadInformation,* заданным **ThreadDynamicCodePolicy,** чтобы иметь возможность выполнять динамический код в этом потоке.

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Защитнике для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-low-integrity-images"></a>Блокировать изображений с низкой целостностью

### <a name="description"></a>Описание

Блокировка изображений с низкой целостностью не позволяет приложению загружать файлы, которые не соответствуют действительности, как правило, потому, что они были загружены из Интернета из браузера с песочницами.

Это смягчение будет блокировать нагрузки на изображение, если на изображении есть запись управления доступом (ACE), которая предоставляет доступ к низким il-процессам и не имеет ACE метки доверия. Он реализуется диспетчером памяти, который блокирует, чтобы файл не был соедем в память. Если приложение пытается наметить изображение низкой целостности, это вызовет STATUS_ACCESS_DENIED ошибку. Сведения о том, как работают уровни целостности, см. в материале [Mandatory Integrity Control.](/windows/win32/secauthz/mandatory-integrity-control)

### <a name="compatibility-considerations"></a>Соображения совместимости

Блокировка изображений с низкой целостностью не позволяет приложению загружать файлы, скачаемые из Интернета. Если рабочий процесс приложения требует загрузки скачаемых изображений, необходимо убедиться, что они загружены из процесса с более высоким доверием или явно перезаверяются, чтобы применить это смягчение.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-remote-images"></a>Блокировать удаленные изображения

### <a name="description"></a>Описание

Блокировка удаленных изображений помогает предотвратить загрузку файлов, которые находятся на удаленном устройстве, например на совместном сайте UNC. Блокировка удаленных изображений помогает защитить от загрузки секонденс в память, которая находится на внешнем устройстве, управляемом злоумышленником.

Это смягчение будет блокировать нагрузки на изображение, если будет определено, что изображение находится на удаленном устройстве. Он реализуется диспетчером памяти, который блокирует, чтобы файл не был соедем в память. Если приложение пытается составить карту удаленного файла, это вызовет STATUS_ACCESS_DENIED ошибку.

### <a name="compatibility-considerations"></a>Соображения совместимости

Блокировка удаленных изображений не позволит приложению загружать изображения с удаленных устройств. Если приложение загружает файлы или плагины с удаленных устройств, оно не будет совместимо с этим смягчением.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-untrusted-fonts"></a>Блокировка ненадежные шрифты

### <a name="description"></a>Описание

Блокировка ненарушенной шрифтов снижает риск ошибки при размыве шрифтов, что приводит к возможности злоумышленника запускать код на устройстве. Только шрифты, установленные в каталоге windows\fonts, будут загружены для обработки GDI.

Это смягчение реализуется в GDI, который проверяет расположение файла. Если файл не находится в каталоге системных шрифтов, шрифт не загружается для размывки, и вызов не будет работать.

Это смягчение является дополнением к встроенной меры по смягчению последствий, предоставляемой в Windows 10 1607 и более поздних версиях, которая перемещает размыв шрифтов из ядра и в контейнер приложений в пользовательском режиме. Любой эксплойт, основанный на размыве шрифтов, происходит в изолированном и изолированном контексте, что значительно снижает риск. Подробные сведения об этом смягчении см. в блоге Hardening Windows 10 с смягчением последствий использования [нулевого дня.](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)

### <a name="compatibility-considerations"></a>Соображения совместимости

Наиболее распространенным использованием шрифтов за пределами каталога системных шрифтов является использование [веб-шрифтов.](/typography/fonts/font-faq#web) Современные браузеры, например Microsoft Edge, используют DirectWrite вместо GDI и не влияют на них. Однако устаревшие браузеры, такие как Internet Explorer 11 (и режим IE в новом Microsoft Edge), могут влиять, особенно с приложениями, такими как Office 365, которые используют глифы шрифтов для отображения пользовательского интерфейса.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="code-integrity-guard"></a>Защита целостности кода

### <a name="description"></a>Описание

Охрана целостности кода гарантирует, что все биналоги, загруженные в процесс, будут подписаны Корпорацией Майкрософт в цифровом формате. Охрана целостности кода включает подписи [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), которые позволят драйверам, утвержденным WHQL, работать в процессе.

Это смягчение реализуется в диспетчере памяти, что блокирует двоичную карту в память. Если вы попытаетесь загрузить двоичный файл, который не подписан Корпорацией Майкрософт, ясль памяти возвращает ошибку STATUS_INVALID_IMAGE_HASH. Блокируя на уровне диспетчера памяти, это предотвращает загрузку обоих бинарей процессом, а также впрыскиваемого в процесс.

### <a name="compatibility-considerations"></a>Соображения совместимости

Это смягчение конкретно блокирует любые двоичные, которые не подписаны Корпорацией Майкрософт. Таким образом, оно будет несовместимо с большинством сторонних программ, если это программное обеспечение не будет распространяться (и подписывался в цифровом формате) Microsoft Store и не будет выбрана возможность загрузки изображений, подписанных Microsoft Store.

### <a name="configuration-options"></a>Параметры конфигурации

Кроме того, разрешить загрузку изображений, подписанных Microsoft Store **—** приложения, распространяемых Microsoft Store, будут цифрово подписаны Microsoft Store, и добавление этой конфигурации позволит загружаться приложениями, которые прошли процесс сертификации магазина.

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="control-flow-guard-cfg"></a>Диспетчерская система потока (CFG)

### <a name="description"></a>Описание

Защита защиты потоков управления (CFG) снижает риск использования злоумышленниками уязвимостей, связанных с повреждениями памяти, за счет защиты непрямых вызовов функций. Например, злоумышленник может использовать уязвимость переполнения буфера, чтобы переписать память, содержащую указатель функции, и заменить этот указатель функции указателем на исполняемый код по своему выбору (который также может быть введен в программу).

Это смягчение обеспечивается путем введения еще одной проверки во время компиляции. Перед каждым косвенным вызовом функции добавляются другие инструкции, которые проверяют, является ли целевой объект вызова допустимой перед вызовом. Если цель не является допустимой целью вызова, приложение прекращается. Таким образом, только приложения, которые компилироваться с поддержкой CFG может извлечь выгоду из этого смягчения.

Проверка допустимой цели предоставляется ядром Windows. При загрузке исполняемых файлов метаданные для непрямых целей вызова извлекаются во время нагрузки и помечены как допустимые цели вызова. Кроме того, если память выделена и помечена как исполняемая (например, для сгенерированного кода), эти расположения памяти также помечены как допустимые целевые объекты вызова, чтобы поддерживать механизмы, такие как компиляция JIT.

### <a name="compatibility-considerations"></a>Соображения совместимости

Так как приложения должны быть компилироваться для поддержки CFG, они неявно объявляют о своей совместимости с ним. Поэтому большинство приложений должны работать с включенной возможностью смягчения последствий. Так как эти проверки скомпилировали в двоичную систему, можно применить конфигурацию, чтобы отключить проверки в Windows ядре. Другими словами, смягчение по умолчанию, но можно настроить ядро Windows, чтобы всегда возвращать "да", если позже вы определите, что существует проблема совместимости, которую разработчик приложения не обнаружил в их тестировании, которая должна быть редкой.

### <a name="configuration-options"></a>Параметры конфигурации

Используйте строгий **CFG** . В строгом режиме для загрузки необходимо скомпилировать все раздвоители, загруженные в процесс, для управления Flow Guard (или не иметь в них исполняемого кода ( например, dlls ресурсов).

> [!Note]
> **У охранника потока управления** нет режима аудита. С помощью этого смягчения будут компилироваться binaries.

## <a name="data-execution-prevention-dep"></a>Предотвращение выполнения данных (DEP)

### <a name="description"></a>Описание

Предотвращение выполнения данных (DEP) предотвращает выполнение памяти, которая явно не была выделена в качестве исполняемой. DEP помогает защититься от впрыскивающего вредоносный код злоумышленника в процесс, например через переполнение буфера, а затем выполняет этот код.

При попытке установить указатель инструкции на адрес памяти, не помеченный как исполняемый, процессор выкинуть исключение (нарушение общей защиты), в результате чего приложение сбой.

### <a name="compatibility-considerations"></a>Соображения совместимости

Все исполняемые ARM, ARM и ARM-64 имеют deP,включенное по умолчанию, и его нельзя отключить. Так как приложение никогда не было выполнено без DEP, предполагается совместимость.

Все двухядрая x86 (32-битные) имеют deP-функции, включенные по умолчанию, но deP можно отключить в процессе. Некоторые старые устаревшие приложения, как правило, приложения, разработанные до Windows XP SP2, могут быть несовместимы с DEP. Такие приложения обычно генерируют код динамически (например, компилятор JIT) или ссылки на более старые библиотеки (например, старые версии ATL), которые динамически создают код.

### <a name="configuration-options"></a>Параметры конфигурации

**Включить эмуляцию ATL Thunk** . Этот параметр настройки отключает эмуляцию ATL Thunk. ATL, библиотека ActiveX шаблонов, рассчитана на максимально малый и быстрый размер. Чтобы уменьшить двоичный размер, он будет использовать метод *thunking*. Thunking обычно используется для взаимодействия между 32-битными и 16-битными приложениями, но 16-битные компоненты ATL здесь не используются. Вместо этого, чтобы оптимизировать двоичный размер, ATL будет хранить машинный код в памяти, не выровненной словом (создание меньшего двоичного), а затем вызывать код напрямую. Компоненты ATL Visual Studio 7.1 или более ранние (Visual Studio 2003 г.) не выделяют эту память как исполняемую — эмуляция thunk устраняет эту проблему совместимости. Приложениям с двоичной моделью расширения (например, Internet Explorer 11) часто требуется включить эмуляцию ATL Thunk.

## <a name="disable-extension-points"></a>Отключить точки расширения

### <a name="description"></a>Описание

Это смягчение отключает различные точки расширения для приложения, которые могут использоваться для установления сохраняемости или повышения привилегий вредоносного контента.

К ним относятся:

- **DLLs AppInit** . Всякий раз, когда начинается процесс, система загружает указанный DLL в контекст только что запущенного процесса, прежде чем вызывать его функцию точки входа. [Подробные сведения о DLLs AppInit можно найти здесь](/windows/win32/winmsg/about-window-classes#application-global-classes). При применении этого смягчения не загружаются DLLs AppInit. Начиная с Windows 7, DLLs AppInit необходимо подписыть в цифровом формате, [как описано здесь.](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2) Кроме того, начиная с Windows 8, DLLs AppInit не загружается, если включен SecureBoot, как [описано здесь.](/windows/win32/dlls/secure-boot-and-appinit-dlls)
- **Устаревшие imEs** — редактор метода ввода (IME) позволяет пользователю вводить текст на языке с большей буквой, чем может быть представлено на клавиатуре. Сторонние стороны могут создавать imEs. Вредоносный IME может получить учетные данные или другую конфиденциальную информацию из этого ввода захвата. Некоторые imEs, именуемые устаревшими imEs, будут работать только Windows настольных приложений, а не приложений UWP. Это смягчение также предотвратит загрузку этого устаревшего IME в указанное Windows настольное приложение.
- **Windows событий** — приложение может вызвать [API SetWinEventHook,](/windows/win32/api/winuser/nf-winuser-setwineventhook) чтобы зарегистрировать интерес к событию, которое происходит. Указывается DLL, который можно ввести в процесс. Это смягчение заставляет крючок быть размещен в процессе регистрации, а не работать в процессе через впрыскивал DLL.

### <a name="compatibility-considerations"></a>Соображения совместимости

Большинство из этих точек расширения используются относительно редко, поэтому влияние на совместимость обычно невелико, особенно на уровне отдельных приложений. Одно из них состоит в том, если пользователи используют сторонние imEs Legacy, которые не будут работать с защищенным приложением.

### <a name="configuration-options"></a>Параметры конфигурации

Параметры конфигурации для этого смягчения не существуют.

> [!Note]
> **Отключение точек расширения** не имеет режима аудита.

## <a name="disable-win32k-system-calls"></a>Отключить системные вызовы Win32k

### <a name="description"></a>Описание

Win32k.sys предоставляет широкую поверхность атаки для злоумышленника. В качестве компонента режима ядра он часто используется в качестве вектора эвакуации для приложений, которые находятся в песочнице. Это смягчение предотвращает вызовы win32k.sys, блокируя преобразование потока в поток GUI, который затем предоставляется доступ для вызова функций Win32k. Поток не является GUI при его создания, но преобразуется при первом вызове в win32k.sys или через вызов API в [IsGuiThread.](/windows/win32/api/winuser/nf-winuser-isguithread)

### <a name="compatibility-considerations"></a>Соображения совместимости

Это смягчение предназначено для процессов, посвященных процессам, не относячим к пользовательскому интерфейсу. Например, многие современные браузеры будут использовать процесс изоляции и включать процессы, не включаемые в пользовательский интерфейс. Любое приложение, которое отображает GUI с помощью одного процесса, будет влиять на это смягчение.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="do-not-allow-child-processes"></a>Не разрешать дочерние процессы

### <a name="description"></a>Описание

Это смягчение не позволяет приложению создавать новые детские приложения. Распространенным методом, используемым противниками, является инициирование доверенного процесса на устройстве с вредоносным вводом (атакой ,живущую за счет земли), которая часто требует запуска другого приложения на устройстве. Если нет законных причин, по которым приложение запускает детский процесс, это смягчение смягчает потенциальный вектор атаки. Смягчение применяется путем установки свойства на маркере процесса, которое блокирует создание маркера для процесса ребенка с сообщением об ошибке STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Соображения совместимости

Если приложение запускает детские приложения по какой-либо причине, например поддерживающие гиперссылки, которые запускают браузер или внешний браузер, или запускают другие утилиты на компьютере, эта функция будет нарушена с помощью этого смягчения.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="export-address-filtering"></a>Фильтрация адресов экспорта

### <a name="description"></a>Описание

Фильтрация адресов экспорта (EAF) снижает риск вредоносных кодов, глядя на таблицу адресов экспорта всех загруженных модулей, чтобы найти модули, содержащие полезные API для их атаки. Это распространенная тактика, используемая в коде shellcode. Чтобы снизить риск подобной атаки, это смягчение защиты защищает три часто атакуемого модуля:

- ntdll.dll
- kernelbase.dll
- kernel32.dll

Смягчение последствий защищает страницу памяти в [экспортируемом каталоге, который указывает на [таблицу адресов экспорта.](/windows/win32/debug/pe-format#export-address-table) На этой странице памяти будет [применена PAGE_GUARD](/windows/win32/memory/creating-guard-pages) защита. Когда кто-то пытается получить доступ к этой памяти, он будет создавать STATUS_GUARD_PAGE_VIOLATION. Это исключение обрабатывается, и если инструкция доступа не проходит проверку, процесс будет прекращен.

### <a name="compatibility-considerations"></a>Соображения совместимости

Это смягчение является в первую очередь проблемой для таких приложений, как отладки, песочницы приложений, приложений с использованием DRM или приложений, реализующих технологию отладки.

### <a name="configuration-options"></a>Параметры конфигурации

**Проверка доступа к** модулям, которые часто используются в эксплойтах, — этот параметр, также известный как EAF+, добавляет защиты для других часто атакованых модулей:

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

Кроме того, включив EAF+, это смягчение добавляет защиту PAGE_GUARD на страницу, содержащую загон "MZ", первые два bytes of the [DOS header in a PE file](/windows/win32/debug/pe-format#ms-dos-stub-image-only), which is another aspect of known memory content which shellcode can look for to identify modules potentially interest in memory.

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="force-randomization-for-images-mandatory-aslr"></a>Принудительный случайный выбор изображений (обязательный ASLR)

### <a name="description"></a>Описание

Рандомизация макета адресов (ASLR) снижает риск использования злоумышленником знаний о макете памяти системы для выполнения кода, который уже присутствует в памяти процесса и уже помечен как исполняемый. Это может снизить риск злоумышленника с помощью таких методов, как атаки return-to-libc, где противник задает контекст, а затем изменяет ответный адрес для выполнения существующего кода с контекстом, который соответствует цели противника.

Обязательный ASLR заставляет повторно использовать все DLLs в процессе. Разработчик может включить ASLR с помощью [параметра linker /DYNAMICBASE,](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) и это смягчение имеет тот же эффект.

При сопоставлении диспетчера памяти в изображении в процесс обязательный ASLR принудительно перебазирует DLLs и EXEs, которые не выбрали asLR. Обратите внимание, однако, что эта rebasing не имеет энтропии, и поэтому может быть размещена в предсказуемом расположении в памяти. Для повторного и рандомизированного расположения бинарей, это смягчение должно быть сопряжено с распределением памяти [Randomize (Снизу вверх ASLR).](#randomize-memory-allocations-bottom-up-aslr)

### <a name="compatibility-considerations"></a>Соображения совместимости

Это влияние на совместимость ASLR обычно ограничивается более старыми приложениями, которые были построены с помощью компиляторов, которые сделали предположения о базовом адресе двоичного файла или лишили базовой информации о переносе. Это может привести к непредсказуемым ошибкам, так как поток выполнения пытается перейти к ожидаемому, а не фактическому расположению в памяти.

### <a name="configuration-options"></a>Параметры конфигурации

**Не допускайте раздельных изображений** — этот параметр блокирует загрузку изображений, которые были лишены данных о переносе. Формат файла Windows pe содержит абсолютные адреса, а компилятор также создает [базовую таблицу перемещения, которую погрузчик может использовать для поиска всех относительных ссылок памяти и их смещения, поэтому они могут обновляться, если двоичный файл не загружается по предпочтительному базовому адресу. Некоторые старые приложения вымежают эту информацию в производственных сборках, и поэтому эти биналоги не могут быть переопостановками. Это смягчение блокирует загрузку таких бинарей (вместо того, чтобы разрешить им загружать по предпочтительному базовому адресу).

> [!Note]
> **Принудительное рандомизация изображений (обязательный ASLR) не** имеет режима аудита.

## <a name="import-address-filtering-iaf"></a>Фильтрация адресов импорта (IAF)

### <a name="description"></a>Описание

Смягчение фильтрации импортных адресов (IAF) помогает снизить риск того, что противник изменит поток управления приложения путем изменения таблицы адресов импорта (IAT) для перенаправления в произвольный код выбора злоумышленника, когда эта функция будет вызвана. Злоумышленник может использовать этот подход для перехвата управления или перехвата, проверки и потенциальной блокировки вызовов для конфиденциальных API.

На страницах памяти для всех защищенных API будет применена PAGE_GUARD [защита.](/windows/win32/memory/creating-guard-pages) Когда кто-то пытается получить доступ к этой памяти, он будет создавать STATUS_GUARD_PAGE_VIOLATION. Это исключение обрабатывается, и если инструкция доступа не проходит проверку, процесс будет прекращен.

Это смягчение защищает следующие Windows API:

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Соображения совместимости

Законные приложения, которые выполняют перехват API, могут быть обнаружены в результате этого смягчения и привести к сбою некоторых приложений. Примеры включают прошивки совместимости программного обеспечения и приложений.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Рандомизация распределений памяти (ASLR снизу вверх)

### <a name="description"></a>Описание

Рандомизация распределений памяти (ASLR снизу вверх) добавляет энтропию к перемещениям, поэтому их расположение рандомизировано и, следовательно, менее предсказуемо. Это смягчение требует, чтобы вступил в силу обязательный asLR.

Размер 32-битного адресного пространства ставит практические ограничения для энтропии, которая может быть добавлена, и поэтому 64-битные приложения затрудняет для злоумышленника угадать расположение в памяти.

### <a name="compatibility-considerations"></a>Соображения совместимости

Большинство приложений, совместимых с обязательной asLR (rebasing), также совместимы с другими энтропиями ASLR bottom-up. В некоторых приложениях могут возникнуть проблемы с указкой-обрезкой, если они сэкономят локальные указатели в 32-битных переменных (ожидается базовый адрес ниже 4 ГБ), что будет несовместимо с вариантом высокой энтропии (который можно отключить).

### <a name="configuration-options"></a>Параметры конфигурации

**Не используйте** высокую энтропию — этот параметр отключает использование ASLR с высокой энтропией, которая добавляет 24 бита энтропии (1 ТБ дисперсии) в распределение снизу вверх для 64-битных приложений.

> [!Note]
> **Рандомизация распределений памяти (ASLR** снизу вверх) не имеет режима аудита.

## <a name="simulate-execution-simexec"></a>Имитация выполнения (SimExec)

### <a name="description"></a>Описание

Имитация выполнения (SimExec) — это смягчение только для 32-битных приложений. Это позволяет проверить, что вызовы конфиденциальных API возвращаются к законным функциям вызываемой звонков. Это делается путем перехвата вызовов в конфиденциальные API, а затем моделирования выполнения этих API, пройдя через закодированные инструкции по языку сборки, ищем инструкцию RET, которая должна вернуться к вызываемой. Затем он проверяет эту функцию и идет в обратном направлении в памяти, чтобы найти предшествующие инструкции call, чтобы определить, совпадает ли функция и инструкция по вызову, и что reT не был перехвачен.

API, перехваченные этим смягчением, являются:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Если обнаружен гаджет ROP, процесс завершается.

### <a name="compatibility-considerations"></a>Соображения совместимости

Приложения, которые выполняют перехват API, в частности программное обеспечение безопасности, могут вызвать проблемы совместимости с этим смягчением.

Это смягчение несовместимо с произвольным смягчением защиты кода.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-api-invocation-callercheck"></a>Проверка вызова API (CallerCheck)

### <a name="description"></a>Описание

Проверка вызова API (CallerCheck) — это смягчение последствий для методов программирования с возвращаемой ориентацией (ROP), которые проверяют, вызывались ли конфиденциальные API от действительного вызываемого. Это смягчение проверяет пройденный обратный адрес, а затем похулиганно разберется назад, чтобы найти вызов над обратным адресом, чтобы определить, соответствует ли целевой вызову параметр, переданный в функцию.

API, перехваченные этим смягчением, являются:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Если обнаружен гаджет ROP, процесс завершается.

### <a name="compatibility-considerations"></a>Соображения совместимости

Приложения, которые выполняют перехват API, в частности программное обеспечение безопасности, могут вызвать проблемы совместимости с этим смягчением.

Это смягчение несовместимо с произвольным смягчением защиты кода.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-exception-chains-sehop"></a>Проверка цепочек исключений (SEHOP)

### <a name="description"></a>Описание

Проверка цепочек исключений (SEHOP) — это смягчение последствий для метода перезаписи обработника структурированных исключений *(SEH).* [Структурированная обработка исключений](/windows/win32/debug/structured-exception-handling) — это процесс, с помощью которого приложение может попросить обработать определенное исключение. Обработчики исключений цепятся вместе, так что если один обработчик исключений не будет обрабатывать определенное исключение, его можно передать следующему обработчику исключений в цепочке до тех пор, пока он не решит обработать его. Так как список обработок динамический, он хранится в стеке. Злоумышленник может использовать уязвимость переполнения стека, чтобы переписать обработчик исключений указателем на код выбора злоумышленника.

Это смягчение зависит от разработки SEH, где каждая запись SEH содержит как указатель обработщика исключений, так и указатель на следующий обработщик в цепочке исключений. Это смягчение вызывается диспетчером исключений, который проверяет цепочку SEH при вызове исключения. Он проверяет, что:

- Все записи цепочки исключений находятся в границах стека
- Все записи исключений выравниваются
- Указатели обработчиков исключений не указывают на стек
- Нет обратных указателей
- Цепочка исключений заканчивается на известном обработнике окончательного исключения

В случае сбоя этих проверки обработка исключений прерывается, и исключение не обрабатывается.

### <a name="compatibility-considerations"></a>Соображения совместимости

Проблемы совместимости с SEHOP являются относительно редкими. Приложение нечасто принимает зависимость от коррупции цепочки исключений. Однако на некоторые приложения влияют незначительные изменения во времени, которые могут проявляться как условие гонки, которое выявляет в приложении затаивную многопотоцветную ошибку.

### <a name="configuration-options"></a>Параметры конфигурации

> [!Note]
> **Проверка цепочек исключений (SEHOP)** не имеет режима аудита.

## <a name="validate-handle-usage"></a>Проверка использования дескриптора

### <a name="description"></a>Описание

*Проверка использования ручки* — это смягчение последствий, которое помогает защититься от злоумышленника с помощью существующей ручки для доступа к защищенного объекта. [Ручка](/windows/win32/sysinfo/handles-and-objects) — это ссылка на защищенный объект. Если код приложения ссылается на недействительные ручки, это может указывать на то, что злоумышленник пытается использовать записанную ранее ручку (но о которой учет ссылок приложения не будет знать). Если приложение пытается использовать недействительный объект, а не просто возвращает null, приложение будет делать исключение (STATUS_INVALID_HANDLE).

Это смягчение автоматически применяется к приложениям Windows Store.

### <a name="compatibility-considerations"></a>Соображения совместимости

Приложения, которые не были точно отслеживали ссылки на ручки и не заверяли эти операции в обработчики исключений, потенциально будут влиять на это смягчение.

### <a name="configuration-options"></a>Параметры конфигурации

> [!Note]
> **Проверка использования ручки** не имеет режима аудита.

## <a name="validate-heap-integrity"></a>Проверка целостности кучи

### <a name="description"></a>Описание

Проверка  снижения целостности кучи повышает уровень защиты от последствий кучи в Windows, что приводит к прекращению приложения при обнаружении повреждения кучи. К числу смягчающих последствий относятся:

- Предотвращение освободить ручку HEAP
- Выполнение другой проверки в расширенных загонах блока для выделения кучи
- Проверка того, что выделение кучи еще не помечено как в использовании
- Добавление страниц охраны к большим выделениям, сегментам кучи и подсетям с минимальным размером

### <a name="compatibility-considerations"></a>Соображения совместимости

Это смягчение уже применяется по умолчанию для 64-битных приложений и для 32-битных приложений, Windows Vista или более поздней. Устаревшие приложения Windows XP или более ранних версий являются наиболее рискованными, хотя проблемы с совместимостью встречаются редко.

### <a name="configuration-options"></a>Параметры конфигурации

> [!Note]
> **Проверка целостности кучи не** имеет режима аудита.

## <a name="validate-image-dependency-integrity"></a>Проверка целостности зависимостей изображения

### <a name="description"></a>Описание

Проверка *смягчения зависимости* от изображений помогает защититься от атак, которые пытаются заменить код для dlls, которые статически связаны Windows binaries. Метод установки DLL злоупотребляет механизмом поиска погрузщика, чтобы ввести вредоносный код, который можно использовать для получения вредоносного кода, запущенного в повышенном контексте. Когда загрузчик загружает подписанный двоичный Windows, а затем загружает все dlls, которые зависят от двоичного, эти двоичные данные будут проверены, чтобы убедиться, что они также цифрово подписаны как двоичный Windows двоичный. В случае сбой проверки подписи dll не загружается и будет выбрасывать исключение, возвращая состояние STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Соображения совместимости

Проблемы с совместимостью встречаются редко. На приложения, которые зависят от замены Windows на локальные частные версии, также существует небольшой риск выявить тонкие ошибки синхронизации в многопотоковом приложении.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-stack-integrity-stackpivot"></a>Проверка целостности стека (StackPivot)

### <a name="description"></a>Описание

Смягчение последствий проверки целостности стека *(StackPivot)* помогает защититься от атаки стеков, атаки ROP, в которой злоумышленник создает поддельный стек в памяти кучи, а затем угощает приложение возвращением в поддельный стек, который управляет потоком выполнения.

Это смягчение перехватывает многие Windows API и проверяет значение указателя стека. Если адрес указателя стека не упадет между нижней и верхней частью стека, событие будет записано и, если не в режиме аудита, процесс будет прекращен.

API, перехваченные этим смягчением, являются:

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Соображения совместимости

Приложения, использующие поддельные стеки, будут влиять на них, а также существует небольшой риск раскрытия тонких ошибок синхронизации в многопотовых приложениях.
Приложения, которые выполняют перехват API, в частности программное обеспечение безопасности, могут вызвать проблемы совместимости с этим смягчением.

Это смягчение несовместимо с произвольным смягчением защиты кода.

### <a name="configuration-options"></a>Параметры конфигурации

**Только аудит** . Вы можете включить это смягчение в режиме аудита, чтобы оценить потенциальное влияние совместимости на приложение. Затем события аудита можно просматривать либо в зрительских мероприятиях, либо с помощью расширенных методов охоты в [Microsoft Defender для конечной точки.](/microsoft-365/security/defender/advanced-hunting-overview)
